library(glmnet) # Required for cv.glmnet.

LambdaGrid <- function( lambdaMax, numLambda, factor ) {
  # Construct tuning parameter grid ranging between factor*lambdaMax
  #  and factor*(lambdaMax/numLambda) with grid increments of 1 / i.
  #
  # Args:
  #   lambdaMax: Largest tuning parameter.
  #   numLambda: Number of elements that should be in the grid.
  #   factor: Scaling factor that will be applied to to all elements in the grid.
  #
  # Returns:
  #   Vector of tuning parameters of size numLambda.
  #
  # Raises:
  #   Error if numLambda is zero or negative.

  if( numLambda <= 0 ) {
    stop( 'Number of grid elements must be greater than 0.' )
  }

  lambdas <- vector( mode="list", length = numLambda )

  lambdas <- lapply( seq_along(lambdas),
                     function( y, n, i ) { factor*lambdaMax/i },
                     y = lambdas,
                     n = names(lambdas) )

  return( unlist(lambdas) )

}

BetaCol <- function( X, D, i ) {
  # Populate a column of the adjacency matrix ( Beta ) when constructing a
  # connectivity network.
  #
  # Args:
  #   X: An n x p design matrix.
  #   D: A p x p matrix containing pairwise distances between regions.
  #   i: Index of the column being updated.
  #
  # Returns:
  #   Vector corresponding to the i'th column of the adjacency matrix.
  #
  # Raises:
  #   Error if requested index i is larger than number of columns of X.

  n <- dim(X)[1]
  p <- dim(X)[2]

  if( i > n ) {
    stop( "Requested index ", i,
          " is larger than numbers of columns in design matrix ", p )
  }

  y <- X[,i]
  predictor <- scale( X[,-i] )

  # Get distances between the i'th region and all other regions.
  Di <- D[-i,i]

  factor <- sum( Di^3 )/( p - 1 )
  lambdaMax <- max( abs( crossprod( predictor, y ) ) ) / n

  lambdas <- LambdaGrid( lambdaMax, 1000, factor )

  # Calibrate the tuning parameter.
  model <- cv.glmnet( x = predictor,
                      y = y,
                      lambda = lambdas,
                      intercept = TRUE,
                      penalty.factor = Di^3 )

  beta <- array( data = 0, dim = p )

  # Construct a vector using elements from the model, except for the i'th element
  # which is set to zero.
  # The model generated by cv.glmnet has the intercept as the first term, which
  # needs to be removed before populating beta.
  beta[-i] <- coef( model )[-1,]

  return( beta )

}

GraphEstimation <- function( X, D, reproducible = TRUE ) {
  # Estimate a connectivity network ( adjacency matrix ) using the SI method.
  #
  # Args:
  #   X: An n x p design matrix.
  #   D: A p x p matrix containing pairwise distances between regions.
  #   reproducible : Set to TRUE to make results reproducible between runs.
  #
  # Returns:
  #   Adjacency matrix of dimension p x p.
  #
  # Raises:
  #   Error if either X or D contain any non-numeric entries.
  #   Error if matrix dimensions are incorrect.
  #   Error if matrices are 1 x 1 or smaller.
  #   Error if either X or D contain missing ( NA ) values.

  if( !is.numeric(X) ) {
    stop( "The design matrix must contain all numeric values." )
  }

  if( !is.numeric(D) ) {
    stop( "The distance matrix must contain all numeric values." )
  }

  n <- dim(X)[1] # number of samples
  p <- dim(X)[2] # number of regions

  if( ( dim(D)[1] != dim(D)[2] ) || ( dim(D)[1] != p ) ) {
    stop( "Matrix dimensions are incorrect. Design matrix is ",
    dim(X)[1], "x", dim(X)[2] , " and Distance matrix is ",
    dim(D)[1], "x", dim(D)[2] )
  }

  if( ( n <= 1 ) || ( p <= 1 ) ) {
    stop( "All matrix dimensions must be greater than 1 x 1" )
  }

  missing_X <- sum( is.na(X) )
  missing_D <- sum( is.na(D) )

  if( missing_X > 0 ) {
    stop( "Design matrix contained ", missing_X, " missing values." )
  }

  if( missing_D > 0 ) {
    stop( "Distance matrix contained ", missing_D, " missing values." )
  }

  if( reproducible ) {
    set.seed(42)
  }

  betaMatrix <- matrix( data = NA, nrow = p, ncol = p )

  for ( i in 1 : p ) {
    betaMatrix[,i] <- BetaCol( X, D, i )
  }

  # Compute matrix of non-zero entries in the coefficient matrix.
  adjacencyMatrix <- sign( abs( betaMatrix ) )

  # Implement the 'and' rule.
  return( adjacencyMatrix * t( adjacencyMatrix ) )

}
